


<details>
<summary>1장</summary>
<div markdown="1">

### 코드가 ‘지저분’ 하다

컴파일러는 코드가 돌아가기만 하면 되는데 프로그램의 구조를 미적인 기준으로만 판단하는 것이 아닐까?

코드를 수정하려면 사람이 개입되고, **사람은 코드의 미적 상태에 민감하다.**

설계가 나쁜 시스템은 수정하기 어렵다.

수정할 부분을 찾고 기존 코드와 함께 작동하게 할 난이도가 올라간다.

또한 수정 포인트를 찾기 어렵다면 사이드이펙이나 버그가 생길 가능성도 높아진다.

### 코드를 쉽게 파악할 수 있도록 하자.

**프로그램의 작동방식을 더 쉽게 파악할 수 있도록 코드를 여러 함수와 프로그램 요소로 재구성한다.**

프로그램의 구조가 빈약하다면 대체로 구조부터 바로잡은 뒤에 기능을 수정하는 편이 작업하기가 훨씬 수월하다.

프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링 하고 나서 원하는 기능을 추가한다.

### 리팩터링의 첫 단계는 테스트코드

리팩터링에서 테스트의 역할은 굉장히 중요하다.

수정 과정에서 예상치 못한 문제가 발생할 가능성이 크다.

테스트는 내가 저지른 실수로부터 보호해주는 버그 검출기 역할을 해주기 때문이다.

**리팩터링 하기 전 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다.**

**함수 추출하기**

코드 조각을 함수로 추출하고 그 코드가 하는일을 설명하는 이름을 지어준다.

함수 반환값에는 항상 result라는 이름을 쓴다.

그러면 그 변수의 역할을 쉽게 알 수 있다.

**임시 변수를 질의 함수로 바꾸기**

임시 변수들 때문에 로컬 버무이에 존재하는 이름이 늘어나서 추출 작업이 복잡해질 수 있다.

```
const play = plays[aPerformance.playID];
------------------------------------------------------------
function playFor(aPerformance) {
 return plays[aPerformance.playID];
}
cont play = playFor(performance);
```

### 지역 변수

추출 리팩토링 전에는 지역 분수부터 제거하라

유효범위를 신경 써야 할 대상이 줄어들기 때문이다.

임시 변수는 자신이 속한 루틴에서만 의미가 있어서 루틴이 길고 복잡해지기 쉽다.

### 반복문 쪼개기

반복문을 쪼개서 성능이 느려지지 않을 까 걱정할 수 있다.

반복문이 중복되는 것을 꺼리는 이들이 많지만 성능에 미치는 영향이 미미할 때가 많다.

때로 성능에 상당한 영향을 주기도 하지만 잘 다듬어진 코드가 성능 개선 작업도 훨 씬 수월하다.

리팩터링 과정에서 성능이 크게 떨어졌다면 리팩터링 후 시간을 내어 성능을 개선하라 리팩터링 덕분에 성능 개선을 더 효고적으로 수행할 수 있다.

**‘특별한 경우가 아니라면 일단 무시하라’**

### 단계 쪼개기

한 메서드의 로직을 단계를 나누어서 치리한다.

e.g.) 1. 데이터 처리, 2. 데이터 표현

### 조건부 로직을 다형성으로 바꾸기

모든 데이터 변환을 한 곳에서 수행할 수 있어서 코드가 더욱 명확해진다.

**리팩터링 리듬.**

리팩터링은 대부분 코드가 하는일 을 파악하는데서 시작

코드를 읽고, 개선점을 찾고, 리팩터링 작업을 통해 개선점을 코드에 반영하는 식으로 진행

그 결과 코드가 명확해지고 이해하기 더 쉬워진다.

각 단계를 잘게 나누고 매번 컴파일하고 테스트하여 작동하는 상태로 유지한다.

**좋은 코드.**

좋은 코드란 코드를 ‘수정하기 쉬운 정도;

코드를 수정해야 할 상황이 되면 고쳐야 할 곳을 쉽게 찾을 수 있고

오류없이 빠르게 수정할 수 있어야 한다.

건강한 코드베이스는 생산성을 극대화하고 더 빠르고 저렴한 비용으로 제공할 수 있도록 해준다.

코드를 건강하게 관리하려면 팀의 현재와 이상의 차이에 항상 신경 쓰면서, 이상에 가까워지도록 리팩터링 해야 한다.

**효과적인 리팩터링**

단계를 잘게 나눠라, 코드는 절때 깨지지 않으며 작은 단계들이 모여서 상당히 큰 변화를 이룰수 있다.

### Review

리팩터링! 레거시 코드를 더 보기좋게 개선 하면 되는거 아니야?!

리팩터링을 진행하면서 올바르게 리팩터링이 되었는가? 다른 사이드 이펙은 없는지 어떻게 검증할 수 있는가?

무작정 코드부터 고치는것이라니라 올바르고 효과적으로 리팩터링을 진행할 수 있도록 가이드해준다는 느낌을 받았다.

어쩌면 이 내용들이 당연하다고 느낄수 도 있을 것 이라고 생각 할 수 있다.

하지만 실제로 적용하고 있는 사람들은 드물것이라고 생각한다.

1장에서 직접 리팩토링을 진행해보며 테스트 코드에 대한 중요성을 다시한번 깨달을 수 있었고

리팩토링을 진행하는 리듬, 작은 단계, 테스트를 상기시키게 되었다.

</div>
</details>





<details>
<summary>2장</summary>
<div markdown="2">

### 리팩토링, 테스트, 그리고 성능

2장에서는 리팩토링이란 무엇인가? 왜 해야하는가 그리고 리팩토링을 진행하면서 테스트에 대한 중요성을 일깨워준다.

리팩토링에서는 자가 테스트 코드가 핵심 요소라는 것을 강조한다.

자가 테스트코드와 리팩터링을 묶어 TDD라고 말한다.

그리고 성능에 관한 잘못된 생각을 바로 잡아줬다고 느껴졌다.

### 리팩터링이란?

- 코드를 정리하는 작업은 리팩터링이 아니다.
- 리팩터링은 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계를 순차적으로 연결해 큰 변화를 만들어내는 것이다.

### **리팩터링 단계를 잘게 나눠라**

- 단계를 잘게 나눔으로써 작업을 더 빨리처리할 수 있다.
- 디버깅에도 효율적이다.

### 기능 추가냐 리팩터링이냐 명확히 구분해라

- 기능을  추가할때는 기존 코드는 절대 건드리지 않고 새 기능만을 추가한다.
- 리팩토링할 때는 기능 추가는 절대 하지 않고 코드 재구성에만 전념한다.
- 어떤 작업을 진행중인지 차이를 분명하게 인식하라

### 리팩터링하는 이유

- 소프트웨어 설계가 좋아진다.
    - 아키텍처를 충분히 이해하지 못하고 코드를 수정하면 코드로 설계를 파악하기 어렵다.
    - 코드만으로 설계를 파악하기 어려워질수록 설계를 유지하기 어려워진다.
    - 반면 규칙적인 리팩터링은 콛의 구조를 지탱해줄 것이다.
- 소프트웨어를 이해하기 쉬워진다.
    - 컴퓨터에게 시키려는 일과 이를 표현한 코드사이의 간극을 최대한 줄여야 한다. **원하는 바를 정확히 표현하는 일이다**
    - 프로그램을 동작시키는데만 신경쓰다 보면 코드를 다룰 개발자를 생각하지 못한다.
    - **잘 동작하지만 이상적이지 않은 코드가 있다면 리팩터링해라, 목적이 더 잘 드러나게 의도를 더 명확하게 전달하도록 개선할 수 있다**.
- 버그를 쉽게 찾을 수 있다.
    - 리팩터링하면 코드가 하는 일을 깊게 파악할 수 있고 새로 깨달은 것을 코드로 더 잘 표현할 수 있게된다.
- 프로그래밍 속도를 높힐 수 있다
    - 리팩터링은 내부 설계와 가독성이 개선되고 버그가 줄어든다.
    - 하지만 전체 개발속도는 떨어질까 하는 우려가 생긴다.
    - 내부 설계가 잘 도니 소프트웨어는 새로은 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다.
    - 코드가 명확하면 버그를 만들 가능성도 줄어든다.
    - 버그가 생기더라고 디버깅하기 쉽다.
    - 내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다

### 리팩터링은 언제 할까?

- 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전
    - 현재 코드를 살펴보며, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 부분을 찾는다.
- 코드를 이해하기 쉽게 만들기
    - 코드를 수정하려면 코드가 하는 일을 파악해야 한다.
    - 코드의 의도가 더 명확하게 드러나도록 리팩터링 할 수 없는지 찾아본다
- 계획된 리팩터링과 수시로 하는 리팩터링
    - 기능을 추가하거나 버그를 잡는 동안 리팩터링도 함께 진행한다. ( 프로그래밍 관정이 자연스럽게 녹여라)
    - 기능을 추가할 때든 버그를 잡을때든 앞으로의 작업에도 도움을 준다.

### 오래 걸리는 리팩터링

- 오래걸리는 리팩터링에 팀 전체가 매달리지 말자
- 주어진 문제를 조금씩 해결해가는 편이 효과적일 때가 많다.

### 코드 리뷰에 리팩터링 활용하기

- 코드 리뷰는 개발팀 전체에 지식을 전파하는데 좋다.
- 개선 사항은 제안할 뿐만 아니라 새로운 아이디어가 떠오르면 리팩터링하여 쉽게 구현할 수 있는지 살피는 과정을 반복한다. 이 과정을 반복하면 실제 적용했을 때 모습을 더 명확하게 볼 수 있다.
- 리팩터링은 코드 리뷰의 결과를 더 구체적으로 도출하는데 도움을 준다.
    - 즉시 구현해볼 수 있기 때문이다.

### 레거시 코드

- 테스트를 갖추고 있더라도 단번에 리팩터링하지 말자.
- 서로 관련된 부분끼리 나눠서 하나씩 공략해라
- 코드의 한 부분을 훑고 넘어갈 때마다 예전보다 조금이라도 개선하려고 노력해라.

### 테스팅

- 핵심은 오류를 재빨리 잡는데 있다.
- 필요한 것은 자가 테스트 코드 테스트 스위트 그리고 이를 빠르게 실행할 수 있어야 수시로 테스트 하는데 부담이 없다.
- 새 기능을 추가할 때도 훨씬 안전하게 진행할 수 있도록 도와준다.
- 핵심은 테스트가 실패한다면 가장 최근에 통과한 버전에서 무었이 달라졌는지 살펴볼 수 있다는 것.

### 데이터베이스

- 다른 리팩터링과 마찬가지로 전체 변경과정을 작고 독립된 단계들로 쪼개는 것이 핵심이다.
- 단계를 잘게 나누면 쉽게 작성 할 수 있다.
- 여러 단계를 순차적으로 연결해서 데이터베이스의 구조와 그 안에 담긴 데이터를 큰 폭으로 변경할 수도 있다.
- 데이터베이스 리팩터링은 프로덕션 환경에 여러 단계도 나눠서 릴리스하는 것이 대체로 좋다는 점에서 다른 리팩터링과 다르다.

### **처음부터 성능을 고려하며 개발하지 말아라**

- 리팩터링은 성능 좋은 소프트웨어를 만드는데 기여한다.
- 단기적으로 보면 리팩터링 단계에서 성능이 느려질 수도 있다.
- 최적화 단계에서 코드를 튜닝하기 훨씬 유리하다. 결국 더 빠른 소프트웨어를 얻게 될것이다.

### **리팩터링을 먼저 수행하고 그다음 튜닝해라**

- 성능만을 생각하다보면 프로그램은 더 복잡해지고 수정하기 어려운 형태로 변한다고 말한다.
- 또한 소프트웨어가 빨라지면 충분한 보상을 얻겠지만 실제로 그런 경우는 별로 없다

결과적으로

**리팩터링하면 성능이 느려질수 있지만 그와 동시에 성능을 튜닝하기에는 더 쉬워진다.**

먼저 튜닝하기 쉽게 만들고 성능을 튜닝하는것이다.

</div>
</details>